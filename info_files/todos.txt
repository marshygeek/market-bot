#CURRENT TODOS
Overview: The todos might be related to each other -> Please take a quick look at ALL todos and then start implementing a solution.
Always paste the Done todo above the last Done todo.

###########
#DONE TODOS - Finished todo goes here - Latest Todo on top
###########

31)
The logs for all pairs are currently written in one file ( placed orders and filled orders).
-> Every pair should have its own log file e.g ZEC_USD_filled_orders.log and ZEC_placed_orders.log


# implemented in a new branch
30) Should be implemented after the merge.
New functionality: This should first be implemented in a new branch, and later on, after the functionality is well enough
tested we merge it back to master.
Please make sure that this branch is always up-to-date with latest changes from master.

Functionality description:

The amount to buy and to sell should be splitted in chunks and then spread out.
For example:
We specify if we want to use this type of bot or the default: 2 (bot_type_config file)
We specify the total trade amount: 15 000 WAX (chunk_order_bot_config)
Chunk size: 5 000 WAX (chunk_order_bot_config)
Spread : 10% (chunk_order_bot_config)
Start price: The price to begin with should be determined as usual.
For every pair we should be able to specify which type of bot we want to use. For that we should have a new config file:
Pair: Bot Type
WAX/USD: 2
Also a new config file for the new type of Bot is needed (for this bot type: chunk_order_bot_config).


After evaluating the ref market and checking the appropriate derivation, place the order for the first chunk at the same
price we already do right now.
The second chunk should be placed 10% above the first.
The third chunk should be placed 10% above the second.
For Example the price for WAX is 0,100 USD in the ref market
The derivation is 20%
The the sell orders should be placed as follow:
Sell 5000 WAX at 0,120 USD
Sell 5000 WAX at 0,132 USD
Sell 5000 WAX at 0,145 USD

Same for the buying:
The price for WAX is 0,100 USD in the ref market
The derivation is 20%
Buy 5000 WAX at 0,080 USD
Buy 5000 WAX at 0,072 USD
Buy 5000 WAX at 0,0648 USD

The first chunk (in our example:Buy 5000 WAX at 0,080 USD and Sell 5000 WAX at 0,120 USD)
Should have the same behaviour as before, meaning, it should always try to be on top.



29) This is a new functionality whether or not it should be used should be specified in a config file (config file for every pair)
If order cannot be on top, then at least second, or third. But always place the order, don't keep it canceled.
For example:
WAX Sell orders are as follow:
Sell 200 WAX at 0.5 USD
Sell 500 WAX at 0.49 USD <-- This is our order

Now somebody puts an order that is too low for us to beat.
Sell 200 WAX at 0.5 USD
Sell 500 WAX at 0.49 USD <-- This is our order
Sell 100 WAX at 0.1 USD

-> The bot cancels our order
Sell 200 WAX at 0.5 USD
Sell 100 WAX at 0.1 USD

-> The bot checks the best price, finds out that 0.1 USD is too low => puts the order back at 0.49 USD
Sell 200 WAX at 0.5 USD
Sell 500 WAX at 0.49 USD <-- This is our order
Sell 100 WAX at 0.1 USD

28)
Merge branch for todo#20 back to master. There is no need to keep this branch since the functionality of todo#20 crucial. Please make sure that none of the latest functionalities are lost.


26) Just append the new logs into the order log file. The current implementation is overriding the file every time we run the bot.


17) ignore for now: Every order that is placed should be logged into a file...
==> Is already implemented with todo 23#

3) Check my question on the function: place_orders, it is added as comment
=> Clarified
#VERIFIED

2) Rename function are_irrelevant to are_relevant and also return value to a relevant value.
- Please as general rule don't use negation in function names.

1) Partially executed orders are still open, but you cannot get them with fetch_open_orders()
-> They will not appear in that list.
Instead you will have to use fetch_orders() and filter them out. You can find them with the status 'Processing'. Here is an example:

orders = exchange.fetch_orders()
for i in range(0,len(orders)):
     if orders[i]['info']['Status'] == 'Processing' :
             print(orders[i])

Example:
-A partially executed sell order: Sell order of 100 WAX, but only 10 WAX are sold.
90 WAX are still open, but the api will tell you that they are 'Processing'.
-> Now 10 WAX are sold for x ETH. => You can make a new order to buy WAX with x ETH.
The new buy order can be put on our current buy order with same price, no need to cancel the old order. But if it is easier to implement cancelation of old buy order, and then put a new buy order you can also do that.
# Yes it's much easier to cancel standalone order, and put a new pair of orders.

-Same for buying. If for example you have a buy order for 100 WAX, but you only buy 10 WAX. => You put an sell order to sell the 10 WAX


# Added handling of RequestTimeout exceptions
4) 01.05
Priority: Highest
Current Behaviour: If timeout exception occurs -> program crashes and stop working
Expected Behaviour: If timeout exception occurs -> Catch the exception, log it and printout warning and keep the program running. This is the most important thing, the program should not be stoped because of any connectivity error.


# Added new strategy:
# at each moment of time, for each pair (e.g. WAX/eth) there will be:
# n bid orders placed and m ask orders placed (n >= 0; m >= 0)
# If an order is partially filled, for example, we have bought some 5 WAX coins, then there will be m+1-th ask order to be placed. (similarly if we sold some coins)
6) 01.05
Priority: normal
Current Behaviour:
If an order is partially filled, nothing happens.
Expected Behaviour:
If an order is partially filled, for example we have bought some 5 WAX coins -> then those 5 WAX coins should be put to sell.
There are two ways to handle that:
	- Put a new sell order. In that case we would have the old sell order plus this new order. This means, every time we buy some coins, we will have to put them to sell -> In the end we could have many sell order on top of each other.
	- Or you just cancel the old order and put all the coins (the ones we already had + the new ones we just bought) in a new sell order
Note: You can choose option that is easier to implement. I would prefer the first one.
Note: In the example I only mentioned the case for buying coins, but the implementation should be for buying and also selling. Means in the case we sold some coins we should put buy orders.


# Program now will spend money to place order even if we can only place one order (bid or ask)
7) 01.05
Priority: normal
Current Behaviour: In the case we don't have any coins left. For example we sold all WAX. We get an error, for example:
Traceback (most recent call last):
  File "main.py", line 113, in <module>
    coin_balance = balance[coin_id]["free"] * BALANCE_USED_PART
KeyError: '98385941-89b3-45c2-ae8e-b64c6f3bbac9'

Expected Behaviour:
If we don't have balance for a coin -> Just put buy order then.


# Replaced variable 'situation_relevant' with orders_relevancy (calculating relevancy for bid and ask orders separately)
10) 08.05
Priority: high
Current Behaviour: if current bid/ask price is above/below ref market price with a REF_PRICE_DEVIATION => Situation is not relevant and the order is not set.
Expected : 	- If current bid is above ref market price with a REF_PRICE_DEVIATION, but ask price is fine => Only set sell order
	 	- If current ask is below ref market price with a REF_PRICE_DEVIATION, but bid price is fine => Only set bid order


# Half completed. Need to implement waiting for random time before replacing
# Fully completed. wait_info object in class Orders for setting random waiting time
5) 01.05
Priority: low
Current Behaviour:
- If one order is no longer on the top, both orders are then canceled an replaced.
Expected Behaviour:
- If one order is no longer on the top, for example the buy order -> Than only cancel the buy order and replace it on top again.
Note: Replacing the order should be done after a random time from 3min to 7min


9) 08.05
Priority: normal
Current Behaviour: we just have one ref price deviation: REF_PRICE_DEVIATION = 0.05
Expected: I should be able to configure the REF_PRICE_DEVIATION for every coin. -> Maybe you could add a map structure like the one for min amount to trade.
Something like a function that get_ref_price_deviation(coinsymbole) for default if the coin is not in the configuration it returns 0.05 as default


# Added function is_round_successful: checking whether trade between two orders (bid and ask) was successful,
# one of the orders could be partially filled
8) 01.05
Priority: normal
Current Behaviour: Rename and redefine "Round" to a "Trade".


- A complete Trade is: a buy of x coins and sell x of these coins.
- A complete Trade also could be: a sell of x coins and buy x of these coins back.
 -> Trade Check: 	- 1st Check: Balance > Balance before a complete Trade
			- 2nd Check: Compare expected Profit with actual profit, should approximately be the same
			expected profit = (sell_price - buy_price) * number of coins traded
 			actual profit = cost_for_sell_order - cost_for_buy_order


- A partial trade is: Buy of x coins and sell of y coins were y<x
- A partial trade is: Sell of x coins and buy of y coins were y<x
 -> Trade Check: 	- Only the 2nd check: Compare expected Profit with actual profit, should approximately be the same
			expected profit = (sell_price - buy_price) * number of coins traded

			# I'm guessing that here you are implying sell/buy price from API, because otherwise formulas
			# for expected_profit and actual_profit are equal
			actual profit = min(filled_sell, filled_buy) * (sell_price - buy_price)

			actual profit 2= cost_for_sell_order - filled_sell * buy_price in case of filled_sell < filled_buy
			actual profit 2= filled_buy * sell_price  - cost_for_buy_order in case of filled_buy < filled_sell


			Note: To double check the value of cost we will also use a second formula for actual profit: actual profit 2
			Comparing: expected_profit = actual_profit = actual_profit_2 they should be approximately the same


10) Placing wrong buy and sell prices.
Buy/Sell order is placed on top of the current best price. It should be placed below/above the current best prices.
Except in the case we already have orders placed as best prices.


// Fixed in previous commits
11) Placing multiple sell and buy orders on top of each other for WAX/ETH

// The problem was in confusion with the logs. If it's not the case and the problem persists, move this Todo in 'Current' section
12) Not placing sell order for CVC/ETH. Maybe because there no order in the order book.

Here are the logs

Saids-MBP:lykke_market_maker said.salem$ python3.6 main.py
INFO:root:Starting Bot ...
INFO:root:Fetching free balance ...
INFO:root:+ETH : 0.018716982
INFO:root:Order size for ETH: 0.009358491
INFO:root:+LOC : 0.6000000000000001
INFO:root:Order size for LOC: 0.6000000000000001
INFO:root:+CVC : 3.0
INFO:root:Order size for CVC: 3.0
INFO:root:Entering place_orders func, pair: LOC/ETH
INFO:root:Getting reference market order book for: LOC/ETH
INFO:root:There are no asks in the orderbook
INFO:root:Getting the best price for asks from the reference orderbook
INFO:root:Calculating best price for asks with a deviation of:0.5
INFO:root:Getting/calculating best bid price: 0.00139400
INFO:root:Getting/calculating best ask price: 0.00240000
INFO:root:Spread between best bid and best ask: 72.17

INFO:root:Is orders are relevant?
{'bid': False, 'ask': True}
INFO:root:Found placed orders on trading market
INFO:root:Too small amount to place
INFO:root:LOC: amount: 0.6000000000000001 < 1
INFO:root:Entering place_orders func, pair: CVC/ETH
INFO:root:Getting reference market order book for: CVC/ETH
INFO:root:There are no asks in the orderbook
INFO:root:Getting the best price for asks from the reference orderbook
INFO:root:Calculating best price for asks with a deviation of:0.5
INFO:root:Getting/calculating best bid price: 0.00056000
INFO:root:Getting/calculating best ask price: 0.00123708
INFO:root:Spread between best bid and best ask: 120.91

INFO:root:Is orders are relevant?
{'bid': False, 'ask': False}
INFO:root:Found placed orders on trading market
INFO:root:going to sleep for: 15

// Added handling for any exception that may occur (except for KeyboardInterrupt exception of course).
// Bot will continue operating after that
### Main Priority Todo ###
### Make sure that the Bot is always running even after it crashes due to an exception of any kind, bear in mind that
### every time the balance is fetched, an order is placed or the price from the order book is fetched there is a high
### possibility that we encounter an exception! Basically every time we use the ccxt library ###


# Added logging to a json file. This file structured by creation date of an order
13) Every trade that is filled, whether it is partially or completely filled it should be logged into a file. You can use a csv format:
Datetime	CreatedAt	Pair	Volume	Filled	Price	Cost
2018-06-10T08:09:41.973Z	2018-06-10T07:30:59.594Z	LKKUSD	155.0	155.0	0.03856	5.9768
2018-06-10T08:12:31.373Z	2018-06-11T08:20:49.594Z	LKKUSD	155.0	135.0	0.03856	5.2312
2018-06-11T18:16:51.323Z	2018-06-11T08:20:49.594Z	LKKUSD	155.0	20.0	0.03856	0.3312

The orders that are complete has the Status 'Matched' and that are partially filled have the Status 'Processing'

Note:Later on I want to use this information to be displayed in html. You can see an example of the expected html output on the 2 PNG files I added.
I will provide exact information on how we can proceed with the html implementation. But for now just keep in mind that we will have to use this
information later on in some type of html-templates. So I think it might be useful to save these information not only as log but maybe also in a list or dict...


# Bot spreads balance by coins that are present in var PAIRS. So if coin occurs there 1 time, then order size for this coin
# will be the same as balance for it, if 2 times, then order size = balance for this coin / 2
14) Is there a difference between Balance and order size ? When I run the Bot it seems to be always the same.
	-> Balance should return the whole Balance including the balance that is used in current open orders
	-> Ordersize should be what the Bot will be use to trade
	Maybe only the logs are wrong. Anyway the calculation of the order size should be updated as described in 15#

# Added variable USED_BALANCE_PAIRS for distributing balance over coins
# Storing balances for coins from last iteration to check if threshold was passed
15) Priority: Highest
The order size should be calculated differently.
	-> For every Pair I should be able to specify how much I want to use percentage wise. For example, for AGI/ETH:
	-AGI amount: 0.5 (50% of the total AGI balance )
	-ETH amount: 0.05 (5% of the total ETH balance )
	Second Example: AGI/BTC:
	-AGI amount: 0.5 (50% of the total AGI balance )
	-BTC amount: 0.025 (2.5% of the total BTC balance )
	After a trade is executed and the balance of the coin is change nothing should happen until a specific threshold is reached.
	Lets call it the amount_threshold and give it a value of 0.1 or 10%
	If for example we had 1000 AGI and we bought 100 additional AGI for X ETH. Our overall balance of AGI is now 1100.
	From 1000 AGI to 1100 is an increase of 10% which is >= threshold, therefore we should recalculate the order size for all AGI pairs.
	After this trade, also the overall ETH balance was reduced by X ETH. If X is 10% of the overall	ETH balance we should
	also recalculate the order size for every ETH pair. This could also affect other pairs like EOS/ETH or ETH/USD ...
	=> The change of the order size should can take place in the new iteration phase of the Bot.


# you can just add new line in reference_markets.json. e.g. if hitbtc uses IOTA/BTC name:
# "IOT/BTC": "bittrex",  // it was there before
# "IOTA/BTC": "hitbtc",  // line you want to add.
16) Priority: Lowest
The reference markets we introduced do not always have the same terminology. For example BCH/BTC is named BCC/BTC in other exchanges. Or IOT/BTC is named sometimes IOTA/BTC ...
We should add a mapping for that. I think it would be best if we just add it to the mapping in the file for reference markets.
Note: If it is the same name we just put a default value, maybe just null or something.


# Implemented
18) Priority: Highest
In every iteration the bot should check if the order is still the first order in the order book (this works fine) and also at the best price (this is not implemented). For example:
BTC/USD Bids
6590 <-- This one is our order, it is 1 USD above the best price, this is fine for now
6589
6450

Now the order for 6589 USD is removed, in that case our order should be updated to the following price:
6451 <-- This should be the price of our order but is currently not the case
6450

In the current implementation the Bot does not update the price.



21) In ref_deviations.json we have the deviation for the reference markets.
Right now, we use this data for placing the ask and bid price.
We should have one derivation for the ask price and one for the bid price.
Now it is like this:
{
  "WAX/ETH": 0.5,
  "AE/ETH": 0.5,
...}
We could add a new derivation for the ask price:
{
  "WAX/ETH": 0.5, 0.2
  "AE/ETH": 0.5, 0.1
...}



22) I need to configure the bot so that I can use it for coins without a reference market.
Currently it is not possible to use with a pair that has no ref market.
The pairs are set as following:
  "LYKKE/USD": null,
But I m still getting the following error:

Saids-MBP:market_bot said.salem$ python3.6 main.py
2018-07-27 09:34:40,566 - INFO - Starting Bot ...
2018-07-27 09:34:40,566 - WARNING - Pair 'LYKKE/USD' is not found in the reference markets mapping
2018-07-27 09:34:40,566 - ERROR - found inconsistencies in configuration files



25)Priority: highest
After starting the bot with LKK/USD pair I m getting the following error:
Traceback (most recent call last):
  File "main.py", line 50, in <module>
    iterate_pairs(placing_objects, fail_wait_infos, coins_spend_amount)
  File "/Users/said.salem/ownCloud/Trading/LykkeAPI/market_bot/main_funcs.py", line 54, in iterate_pairs
    place_orders(placing_objects, coins_spend_amount[pair], pair)
  File "/Users/said.salem/ownCloud/Trading/LykkeAPI/market_bot/main_funcs.py", line 87, in place_orders
    orders_relevancy = get_orders_relevancy(ref_book, highest_bid_price, lowest_ask_price, pair)
  File "/Users/said.salem/ownCloud/Trading/LykkeAPI/market_bot/common.py", line 72, in get_orders_relevancy
    ref_highest_bid_price = ref_book["bids"][0][0]
TypeError: 'NoneType' object is not subscriptable



24)Add a log file for debuging. Add a debug option in config to switch this on and off.



23)Add a new log file only with information about the placed orders.
For the filled orders we already have a json file. But this file is to illustrate the process logic of placing and canceling orders.

For example:
-2018-06-10T08:09:41: - placed sell order for 50 WAX, price at 0.005 ETH
-2018-06-10T08:09:41: - placed buy order for 50 WAX at 0.0001 ETH
-2018-06-10T08:11:41: - canceled sell order: lower than ref market  "mention one reason or more"
-2018-06-10T08:12:31: - Filled buy of 40 on 50 WAX, price at 0.005 ETH, cost 0.2 ETH

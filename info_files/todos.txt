#CURRENT TODOS
Overview: The todos might be related to each other -> Please take a quick look at ALL todos and then start implementing a solution.

16) Priority: Lowest
The reference markets we introduced do not always have the same terminology. For example BCH/BTC is named BCC/BTC in other exchanges. Or IOT/BTC is named sometimes IOTA/BTC ...
We should add a mapping for that. I think it would be best if we just add it to the mapping in the file for reference markets.
# you can just add new line in reference_markets.json. e.g. if hitbtc uses IOTA/BTC name:
# "IOT/BTC": "bittrex",  // it was there before
# "IOTA/BTC": "hitbtc",  // line you want to add.
Note: If it is the same name we just put a default value, maybe just null or something.

17) ignore for now: Every order that is placed should be logged into a file...


18) Priority: Highest
In every iteration the bot should check if the order is still the first order in the order book (this works fine) and also at the best price (this is not implemented). For example:
BTC/USD Bids
6590 <-- This one is our order, it is 1 USD above the best price, this is fine for now
6589
6450

Now the order for 6589 USD is removed, in that case our order should be updated to the following price:
6451 <-- This should be the price of our order but is currently not the case
6450

In the current implementation the Bot does not update the price.



###########
#DONE TODOS - Finished todo goes here - Latest Todo on top
###########

3) Check my question on the function: place_orders, it is added as comment
=> Clarified
#VERIFIED

2) Rename function are_irrelevant to are_relevant and also return value to a relevant value.
- Please as general rule don't use negation in function names.

1) Partially executed orders are still open, but you cannot get them with fetch_open_orders()
-> They will not appear in that list.
Instead you will have to use fetch_orders() and filter them out. You can find them with the status 'Processing'. Here is an example:

orders = exchange.fetch_orders()
for i in range(0,len(orders)):
     if orders[i]['info']['Status'] == 'Processing' :
             print(orders[i])

Example:
-A partially executed sell order: Sell order of 100 WAX, but only 10 WAX are sold.
90 WAX are still open, but the api will tell you that they are 'Processing'.
-> Now 10 WAX are sold for x ETH. => You can make a new order to buy WAX with x ETH.
The new buy order can be put on our current buy order with same price, no need to cancel the old order. But if it is easier to implement cancelation of old buy order, and then put a new buy order you can also do that.
# Yes it's much easier to cancel standalone order, and put a new pair of orders.

-Same for buying. If for example you have a buy order for 100 WAX, but you only buy 10 WAX. => You put an sell order to sell the 10 WAX


# Added handling of RequestTimeout exceptions
4) 01.05
Priority: Highest
Current Behaviour: If timeout exception occurs -> program crashes and stop working
Expected Behaviour: If timeout exception occurs -> Catch the exception, log it and printout warning and keep the program running. This is the most important thing, the program should not be stoped because of any connectivity error.


# Added new strategy:
# at each moment of time, for each pair (e.g. WAX/eth) there will be:
# n bid orders placed and m ask orders placed (n >= 0; m >= 0)
# If an order is partially filled, for example, we have bought some 5 WAX coins, then there will be m+1-th ask order to be placed. (similarly if we sold some coins)
6) 01.05
Priority: normal
Current Behaviour:
If an order is partially filled, nothing happens.
Expected Behaviour:
If an order is partially filled, for example we have bought some 5 WAX coins -> then those 5 WAX coins should be put to sell.
There are two ways to handle that:
	- Put a new sell order. In that case we would have the old sell order plus this new order. This means, every time we buy some coins, we will have to put them to sell -> In the end we could have many sell order on top of each other.
	- Or you just cancel the old order and put all the coins (the ones we already had + the new ones we just bought) in a new sell order
Note: You can choose option that is easier to implement. I would prefer the first one.
Note: In the example I only mentioned the case for buying coins, but the implementation should be for buying and also selling. Means in the case we sold some coins we should put buy orders.


# Program now will spend money to place order even if we can only place one order (bid or ask)
7) 01.05
Priority: normal
Current Behaviour: In the case we don't have any coins left. For example we sold all WAX. We get an error, for example:
Traceback (most recent call last):
  File "main.py", line 113, in <module>
    coin_balance = balance[coin_id]["free"] * BALANCE_USED_PART
KeyError: '98385941-89b3-45c2-ae8e-b64c6f3bbac9'

Expected Behaviour:
If we don't have balance for a coin -> Just put buy order then.


# Replaced variable 'situation_relevant' with orders_relevancy (calculating relevancy for bid and ask orders separately)
10) 08.05
Priority: high
Current Behaviour: if current bid/ask price is above/below ref market price with a REF_PRICE_DEVIATION => Situation is not relevant and the order is not set.
Expected : 	- If current bid is above ref market price with a REF_PRICE_DEVIATION, but ask price is fine => Only set sell order
	 	- If current ask is below ref market price with a REF_PRICE_DEVIATION, but bid price is fine => Only set bid order


# Half completed. Need to implement waiting for random time before replacing
# Fully completed. wait_info object in class Orders for setting random waiting time
5) 01.05
Priority: low
Current Behaviour:
- If one order is no longer on the top, both orders are then canceled an replaced.
Expected Behaviour:
- If one order is no longer on the top, for example the buy order -> Than only cancel the buy order and replace it on top again.
Note: Replacing the order should be done after a random time from 3min to 7min


9) 08.05
Priority: normal
Current Behaviour: we just have one ref price deviation: REF_PRICE_DEVIATION = 0.05
Expected: I should be able to configure the REF_PRICE_DEVIATION for every coin. -> Maybe you could add a map structure like the one for min amount to trade.
Something like a function that get_ref_price_deviation(coinsymbole) for default if the coin is not in the configuration it returns 0.05 as default


# Added function is_round_successful: checking whether trade between two orders (bid and ask) was successful,
# one of the orders could be partially filled
8) 01.05
Priority: normal
Current Behaviour: Rename and redefine "Round" to a "Trade".


- A complete Trade is: a buy of x coins and sell x of these coins.
- A complete Trade also could be: a sell of x coins and buy x of these coins back.
 -> Trade Check: 	- 1st Check: Balance > Balance before a complete Trade
			- 2nd Check: Compare expected Profit with actual profit, should approximately be the same
			expected profit = (sell_price - buy_price) * number of coins traded
 			actual profit = cost_for_sell_order - cost_for_buy_order


- A partial trade is: Buy of x coins and sell of y coins were y<x
- A partial trade is: Sell of x coins and buy of y coins were y<x
 -> Trade Check: 	- Only the 2nd check: Compare expected Profit with actual profit, should approximately be the same
			expected profit = (sell_price - buy_price) * number of coins traded

			# I'm guessing that here you are implying sell/buy price from API, because otherwise formulas
			# for expected_profit and actual_profit are equal
			actual profit = min(filled_sell, filled_buy) * (sell_price - buy_price)

			actual profit 2= cost_for_sell_order - filled_sell * buy_price in case of filled_sell < filled_buy
			actual profit 2= filled_buy * sell_price  - cost_for_buy_order in case of filled_buy < filled_sell


			Note: To double check the value of cost we will also use a second formula for actual profit: actual profit 2
			Comparing: expected_profit = actual_profit = actual_profit_2 they should be approximately the same


10) Placing wrong buy and sell prices.
Buy/Sell order is placed on top of the current best price. It should be placed below/above the current best prices.
Except in the case we already have orders placed as best prices.


// Fixed in previous commits
11) Placing multiple sell and buy orders on top of each other for WAX/ETH

// The problem was in confusion with the logs. If it's not the case and the problem persists, move this Todo in 'Current' section
12) Not placing sell order for CVC/ETH. Maybe because there no order in the order book.

Here are the logs

Saids-MBP:lykke_market_maker said.salem$ python3.6 main.py
INFO:root:Starting Bot ...
INFO:root:Fetching free balance ...
INFO:root:+ETH : 0.018716982
INFO:root:Order size for ETH: 0.009358491
INFO:root:+LOC : 0.6000000000000001
INFO:root:Order size for LOC: 0.6000000000000001
INFO:root:+CVC : 3.0
INFO:root:Order size for CVC: 3.0
INFO:root:Entering place_orders func, pair: LOC/ETH
INFO:root:Getting reference market order book for: LOC/ETH
INFO:root:There are no asks in the orderbook
INFO:root:Getting the best price for asks from the reference orderbook
INFO:root:Calculating best price for asks with a deviation of:0.5
INFO:root:Getting/calculating best bid price: 0.00139400
INFO:root:Getting/calculating best ask price: 0.00240000
INFO:root:Spread between best bid and best ask: 72.17

INFO:root:Is orders are relevant?
{'bid': False, 'ask': True}
INFO:root:Found placed orders on trading market
INFO:root:Too small amount to place
INFO:root:LOC: amount: 0.6000000000000001 < 1
INFO:root:Entering place_orders func, pair: CVC/ETH
INFO:root:Getting reference market order book for: CVC/ETH
INFO:root:There are no asks in the orderbook
INFO:root:Getting the best price for asks from the reference orderbook
INFO:root:Calculating best price for asks with a deviation of:0.5
INFO:root:Getting/calculating best bid price: 0.00056000
INFO:root:Getting/calculating best ask price: 0.00123708
INFO:root:Spread between best bid and best ask: 120.91

INFO:root:Is orders are relevant?
{'bid': False, 'ask': False}
INFO:root:Found placed orders on trading market
INFO:root:going to sleep for: 15

// Added handling for any exception that may occur (except for KeyboardInterrupt exception of course).
// Bot will continue operating after that
### Main Priority Todo ###
### Make sure that the Bot is always running even after it crashes due to an exception of any kind, bear in mind that
### every time the balance is fetched, an order is placed or the price from the order book is fetched there is a high
### possibility that we encounter an exception! Basically every time we use the ccxt library ###


# Added logging to a json file. This file structured by creation date of an order
13) Every trade that is filled, whether it is partially or completely filled it should be logged into a file. You can use a csv format:
Datetime	CreatedAt	Pair	Volume	Filled	Price	Cost
2018-06-10T08:09:41.973Z	2018-06-10T07:30:59.594Z	LKKUSD	155.0	155.0	0.03856	5.9768
2018-06-10T08:12:31.373Z	2018-06-11T08:20:49.594Z	LKKUSD	155.0	135.0	0.03856	5.2312
2018-06-11T18:16:51.323Z	2018-06-11T08:20:49.594Z	LKKUSD	155.0	20.0	0.03856	0.3312

The orders that are complete has the Status 'Matched' and that are partially filled have the Status 'Processing'

Note:Later on I want to use this information to be displayed in html. You can see an example of the expected html output on the 2 PNG files I added.
I will provide exact information on how we can proceed with the html implementation. But for now just keep in mind that we will have to use this
information later on in some type of html-templates. So I think it might be useful to save these information not only as log but maybe also in a list or dict...


# Bot spreads balance by coins that are present in var PAIRS. So if coin occurs there 1 time, then order size for this coin
# will be the same as balance for it, if 2 times, then order size = balance for this coin / 2
14) Is there a difference between Balance and order size ? When I run the Bot it seems to be always the same.
	-> Balance should return the whole Balance including the balance that is used in current open orders
	-> Ordersize should be what the Bot will be use to trade
	Maybe only the logs are wrong. Anyway the calculation of the order size should be updated as described in 15#

# Added variable USED_BALANCE_PAIRS for distributing balance over coins
# Storing balances for coins from last iteration to check if threshold was passed
15) Priority: Highest
The order size should be calculated differently.
	-> For every Pair I should be able to specify how much I want to use percentage wise. For example, for AGI/ETH:
	-AGI amount: 0.5 (50% of the total AGI balance )
	-ETH amount: 0.05 (5% of the total ETH balance )
	Second Example: AGI/BTC:
	-AGI amount: 0.5 (50% of the total AGI balance )
	-BTC amount: 0.025 (2.5% of the total BTC balance )
	After a trade is executed and the balance of the coin is change nothing should happen until a specific threshold is reached.
	Lets call it the amount_threshold and give it a value of 0.1 or 10%
	If for example we had 1000 AGI and we bought 100 additional AGI for X ETH. Our overall balance of AGI is now 1100.
	From 1000 AGI to 1100 is an increase of 10% which is >= threshold, therefore we should recalculate the order size for all AGI pairs.
	After this trade, also the overall ETH balance was reduced by X ETH. If X is 10% of the overall	ETH balance we should
	also recalculate the order size for every ETH pair. This could also affect other pairs like EOS/ETH or ETH/USD ...
	=> The change of the order size should can take place in the new iteration phase of the Bot.
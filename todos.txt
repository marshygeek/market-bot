#CURRENT TODOS
Overview: The todos might be related to each other, especially 6 and 7 -> Please take a quick look at ALL todos and then start implementing a solution.  

# Added handling of RequestTimeout exceptions
4) 01.05
Priority: Highest
Current Behaviour: If timeout exception occurs -> program crashes and stop working
Expected Behaviour: If timeout exception occurs -> Catch the exception, log it and printout warning and keep the program running. This is the most important thing, the program should not be stoped because of any connectivity error.

5) 01.05
Priority: low
Current Behaviour:
- If one order is no longer on the top, both orders are then canceled an replaced.
Expected Behaviour:
- If one order is no longer on the top, for example the buy order -> Than only cancel the buy order and replace it on top again.
Note: Replacing the order should be done after a random time from 3min to 7min





8) 01.05
Priority: normal
Current Behaviour: Rename and redefine "Round" to a "Trade".


- A complete Trade is: a buy of x coins and sell x of these coins.
- A complete Trade also could be: a sell of x coins and buy x of these coins back.
 -> Trade Check: 	- 1st Check: Balance > Balance before a complete Trade
			- 2nd Check: Compare expected Profit with actual profit, should approximately be the same
			expected profit = (sell_price - buy_price) * number of coins traded
 			actual profit = current_balance - before_trade_started_balance
- A partial trade is: Buy of x coins and sell of y coins were y<x
- A partial trade is: Sell of x coins and buy of y coins were y<x
 -> Trade Check: 	- Only the 2nd check: Compare expected Profit with actual profit, should approximately be the same
			expected profit = (sell_price - buy_price) * (number of coins traded) => min(number of bought, number of sold)
 			actual profit = after_bought_after_partially_sold_balance - before_bought_before_sold_balance * ( number_of_coins_partially_sold / total_number_of_coins_initialy bought)
			example:
				- Total bought 1000 XYZCoins for 1 ETH -> before_bought_before_sold_balance = 1 ETH and after_bought_before_sold_balance = 0 ETH
				- Partially Sold 500 XYCoins for 0.6 ETH -> after_partially_sold_balance = 0.6 ETH
				=> Therefore: after_bought_after_partially_sold_balance - before_bought_before_sold_balance * ( number_of_coins_partially_sold / total_number_of_coins_initialy bought)
				-> 		0.6 ETH - 1 ETH * ( 500 / 1000)  --> Partial Profit would be in our case 0.1 ETH

			Note: We cannot really calculate the actual profit since our total balance after a partial trade might still be lower then before the trade




#DONE TODOS - Finished todo goes here
3) Check my question on the function: place_orders, it is added as comment
=> Clarified
#VERIFIED

2) Rename function are_irrelevant to are_relevant and also return value to a relevant value.
- Please as general rule don't use negation in function names.

1) Partially executed orders are still open, but you cannot get them with fetch_open_orders()
-> They will not appear in that list.
Instead you will have to use fetch_orders() and filter them out. You can find them with the status 'Processing'. Here is an example:

>>> orders = exchange.fetch_orders()
>>> for i in range(0,len(orders)):
...     if orders[i]['info']['Status'] == 'Processing' :
...             print(orders[i])

Example:
-A partially executed sell order: Sell order of 100 WAX, but only 10 WAX are sold.
90 WAX are still open, but the api will tell you that they are 'Processing'.
-> Now 10 WAX are sold for x ETH. => You can make a new order to buy WAX with x ETH.
The new buy order can be put on our current buy order with same price, no need to cancel the old order. But if it is easier to implement cancelation of old buy order, and then put a new buy order you can also do that.
# Yes it's much easier to cancel standalone order, and put a new pair of orders.

-Same for buying. If for example you have a buy order for 100 WAX, but you only buy 10 WAX. => You put an sell order to sell the 10 WAX


# Added new strategy:
# at each moment of time, for each pair (e.g. WAX/eth) there will be:
# n bid orders placed and m ask orders placed (n >= 0; m >= 0)
# If an order is partially filled, for example, we have bought some 5 WAX coins, then there will be m+1-th ask order to be placed. (similarly if we sold some coins)
6) 01.05
Priority: normal
Current Behaviour:
If an order is partially filled, nothing happens.
Expected Behaviour:
If an order is partially filled, for example we have bought some 5 WAX coins -> then those 5 WAX coins should be put to sell.
There are two ways to handle that:
	- Put a new sell order. In that case we would have the old sell order plus this new order. This means, every time we buy some coins, we will have to put them to sell -> In the end we could have many sell order on top of each other.
	- Or you just cancel the old order and put all the coins (the ones we already had + the new ones we just bought) in a new sell order
Note: You can choose option that is easier to implement. I would prefer the first one.
Note: In the example I only mentioned the case for buying coins, but the implementation should be for buying and also selling. Means in the case we sold some coins we should put buy orders.


# Program now will spend money to place order even if we can only place one order (bid or ask)
7) 01.05
Priority: normal
Current Behaviour: In the case we don't have any coins left. For example we sold all WAX. We get an error, for example:
Traceback (most recent call last):
  File "main.py", line 113, in <module>
    coin_balance = balance[coin_id]["free"] * BALANCE_USED_PART
KeyError: '98385941-89b3-45c2-ae8e-b64c6f3bbac9'

Expected Behaviour:
If we don't have balance for a coin -> Just put buy order then.
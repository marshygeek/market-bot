#CURRENT TODOS
Overview: The todos might be related to each other, especially 6 and 7 -> Please take a quick look at ALL todos and then start implementing a solution.  

4) 01.05
Priority: Highest
Current Behaviour: If timeout exception occurs -> program crashes and stop working
Expected Behaviour: If timeout exception occurs -> Catch the exception, log it and printout warning and keep the program running. This is the most important thing, the program should not be stoped because of any connectivity error.

5) 01.05
Priority: low
Current Behaviour:
- If one order is no longer on the top, both orders are then canceled an replaced.
Expected Behaviour:
- If one order is no longer on the top, for example the buy order -> Than only cancel the buy order and replace it on top again.
Note: Replacing the order should be done after a random time from 3min to 7min

6) 01.05
Priority: normal
Current Behaviour:
If an order is partially filled, nothing happens.
Expected Behaviour:
If an order is partially filled, for example we have bought some 5 WAX coins -> then those 5 WAX coins should be put to sell.
There are two ways to handle that:
	- Put a new sell order. In that case we would have the old sell order plus this new order. This means, every time we buy some coins, we will have to put them to sell -> In the end we could have many sell order on top of each other.
	- Or you just cancel the old order and put all the coins (the ones we already had + the new ones we just bought) in a new sell order
Note: You can choose option that is easier to implement. I would prefer the first one.
Note: In the example I only mentioned the case for buying coins, but the implementation should be for buying and also selling. Means in the case we sold some coins we should put buy orders.


7) 01.05
Priority: normal
Current Behaviour: In the case we don't have any coins left. For example we sold all WAX. We get an error, for example:
Traceback (most recent call last):
  File "main.py", line 113, in <module>
    coin_balance = balance[coin_id]["free"] * BALANCE_USED_PART
KeyError: '98385941-89b3-45c2-ae8e-b64c6f3bbac9'

Expected Behaviour:
If we don't have balance for a coin -> Just put buy order then.




8) 01.05
Priority: low
Current Behaviour:
Expected Behaviour:


#DONE TODOS - Finished todo goes here
3) Check my question on the function: place_orders, it is added as comment
=> Clarified
#VERIFIED

2) Rename function are_irrelevant to are_relevant and also return value to a relevant value.
- Please as general rule don't use negation in function names.

1) Partially executed orders are still open, but you cannot get them with fetch_open_orders()
-> They will not appear in that list.
Instead you will have to use fetch_orders() and filter them out. You can find them with the status 'Processing'. Here is an example:

>>> orders = exchange.fetch_orders()
>>> for i in range(0,len(orders)):
...     if orders[i]['info']['Status'] == 'Processing' :
...             print(orders[i])

Example:
-A partially executed sell order: Sell order of 100 WAX, but only 10 WAX are sold.
90 WAX are still open, but the api will tell you that they are 'Processing'.
-> Now 10 WAX are sold for x ETH. => You can make a new order to buy WAX with x ETH.
The new buy order can be put on our current buy order with same price, no need to cancel the old order. But if it is easier to implement cancelation of old buy order, and then put a new buy order you can also do that.
# Yes it's much easier to cancel standalone order, and put a new pair of orders.

-Same for buying. If for example you have a buy order for 100 WAX, but you only buy 10 WAX. => You put an sell order to sell the 10 WAX